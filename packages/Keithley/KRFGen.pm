package KRFGen;
use warnings;
use strict;
use lib '/dm5/ki/adaptive_infrastructure/packages';
use Carp;
use Data::Dumper;
use Logging;
use Components::DeviceString;

sub get_recipe_for_sms_record{
    my ($sms_rec, $type) = @_;
    my $recipe = $sms_rec->get("RECIPE");
    my $base_wdf = $sms_rec->get("PROBER_FILE");
    my $wdf = WDFGen::make_wdf_name($base_wdf, $type);
    my $cpf = CPFGen::get_cpf_name($sms_rec);
    my $autoz = WDFGen::is_autoz($sms_rec);
    my $klf = $sms_rec->get("PROGRAM");
    my $device_string = DeviceString::get_device_string($sms_rec->get("TECHNOLOGY"), $sms_rec->get("PROGRAM"));
    my $text = get_text($recipe, $cpf_base, $autoz, $klf, $device_string);
    return $text;
}

sub get_text{
    my ($recipe, $cpf_base, $autoz, $wdf, $klf, $device_string) = @_;
    my $cpf = make_cpf_name($cpf_base, $autoz);
    $recipe = clean_filename($recipe, "krf");
    $cpf = clean_filename($cpf, "cpf");
    $wdf = clean_filename($wdf, "wdf");
    $klf = clean_filename($klf, "klf");
    my $text = qq{
        # Keithley Recipe Definition File
        Version,1.0
        File,$recipe.krf
        Date,
        Comment,Auto-generated by new adaptive infrastructure
        RevID,\$Revision: 1.0 \$
        <EOH>
        cpf,$cpf.cpf
        wdf,$wdf.wdf
        klf,$klf.klf
    };
    if (defined $device_string && $device_string !~ m{^/*$}){
        $text .= "usrField2,$device_string\n" if defined $device_string
    }
    $text .= q{
        command_line,
        <EOR>
    };
    $text =~ join("\n", map {s/^\s*//; $_} grep {m/\S/} split(/\n/, $text));
    return $text;
}

sub make_cpf_name{
    my ($cpf_base, $autoz) = @_;
    $cpf_base =~ s/_AUTO//;
    $cpf_base = clean_filename($cpf_base, 'cpf');
    return $cpf_base . ($autoz ? "_AUTO" : "");    
}

sub clean_filename{
    my ($filename, $fext) = @_;
    $filename =~ s#.*/##;
    $filename =~ s/\.$fext//i;
    return $filename;
}

1;
